\section{Creazione DB}
In questa sezione si illustra il processo di progettazione e sviluppo del database realizzato dall'Agenzia Spaziale Internazionale ArtemisCartesio. L'architettura del database è stata concepita con l'obiettivo di soddisfare i requisiti operativi del sistema di monitoraggio e controllo delle missioni spaziali, garantendo al contempo una gestione efficiente e una memorizzazione accurata dei dati. Tale sistema comprende informazioni relative alle missioni, ai membri dell'equipaggio, ai sensori, ai robot, alle anomalie, alle rilevazioni e ai report, assicurando una struttura ottimizzata per la loro archiviazione e consultazione.

\subsection{Progettazione Concettuale}

La \textbf{progettazione concettuale} rappresenta la fase iniziale e fondamentale nel processo di progettazione di un database. Durante questa fase, vengono definiti i requisiti del sistema, identificando le entità coinvolte, le relazioni che intercorrono tra di esse e gli attributi che le descrivono. Questo approccio si caratterizza per la sua indipendenza dal modello logico e si focalizza esclusivamente sulla rappresentazione astratta dei dati, senza considerare i dettagli implementativi o tecnologici.\\
Nel contesto di questo progetto, la progettazione concettuale è stata realizzata adottando il \textbf{modello Entità/Relazione (E/R)}. Tale modello, grazie alla sua struttura chiara e intuitiva, ha consentito di rappresentare in maniera efficace le entità del sistema, le loro relazioni e i rispettivi attributi, costituendo così una solida base per le fasi successive di progettazione e implementazione del database.

\subsubsection{Modello E/R portante}

Come prima fase della progettazione concettuale, è stato realizzato uno schema E/R portante. Lo schema portante rappresenta il \textbf{nucleo centrale del modello Entità-Relazione (E/R)} per il sistema in esame. Esso evidenzia le principali entità coinvolte: \textbf{RISORSA}, \textbf{MISSIONE} e \textbf{MEMBRO EQUIPAGGIO}, connesse tra loro tramite relazioni chiave.

\begin{itemize}
    \item La \textbf{RISORSA} rappresenta gli strumenti, le tecnologie o gli elementi utilizzati nelle missioni spaziali, essenziali per il loro svolgimento.
    \item La \textbf{MISSIONE} costituisce il fulcro operativo del sistema, in cui le risorse vengono assegnate e gestite, e i membri dell'equipaggio collaborano per il raggiungimento degli obiettivi prefissati
    \item Il \textbf{MEMBRO EQUIPAGGIO} indica le persone coinvolte nelle missioni, caratterizzate da ruoli specifici e responsabilità ben definite.
\end{itemize}
\noindent
Le relazioni delineano i collegamenti logici tra le entità principali, evidenziando i meccanismi di assegnazione e utilizzo delle risorse e del personale nel contesto delle missioni. Questi collegamenti definiscono in modo chiaro e strutturato come le entità interagiscono tra loro, garantendo la coerenza e l'integrità dei dati all'interno del sistema.\\
Lo schema E/R così elaborato rappresenta una base fondamentale per le successive fasi di progettazione, sia logica che fisica, fornendo una struttura solida e ben definita per l’implementazione del database.

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{Media/schema_portante.png}
    \caption{Schema portante del modello E/R}
    \label{fig:schema_portante}
\end{figure}


\subsubsection{Modello E/R completo}

A partire dallo schema portante precedentemente descritto, è stato sviluppato uno schema Entità-Relazione (E/R) completo, che integra tutte le entità e le relazioni coinvolte nel sistema. Questo schema fornisce una rappresentazione esaustiva della struttura del sistema, includendo non solo le principali entità e relazioni, ma anche gli attributi che ne caratterizzano il comportamento e le proprietà.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{Media/ER_Completo.png}
    \caption{Modello E/R completo}
    \label{fig:schema_portante}
\end{figure}

\paragraph{Specifiche di Progettazione}

\begin{itemize}
    \item \textbf{MISSIONE}: L'entità \textbf{MISSIONE} è identificata da un \textit{ID} e caratterizzata dagli attributi: \textit{Obiettivo}, \textit{Data di inizio}, \textit{Data di fine} e \textit{Stato}. Ogni \textbf{MISSIONE} è in relazione con i \textbf{MEMBRI DELL'EQUIPAGGIO} tramite l'associazione \textbf{PARTECIPAZIONE} con cardinalità $(1,N)$, poiché una missione può coinvolgere uno o più membri dell'equipaggio, mentre un membro può partecipare a zero o più missioni $(0,N)$. L'associazione è di tipo molti-a-molti. Ogni \textbf{MISSIONE} è anche in una relazione di \textbf{UTILIZZO} con \textbf{RISORSA}. Una \textbf{MISSIONE} può utilizzare $(1,N)$ risorse (non $(0,N)$ in quanto una missione non avrebbe senso di esistere se non vi fosse associata almeno una risorsa) e una \textbf{RISORSA} può essere usata da $(0,N)$ missioni.
    
    \item \textbf{MEMBRO DELL'EQUIPAGGIO}: L'entità \textbf{MEMBRO DELL'EQUI-\\PAGGIO} è identificata da un \textit{Codice univoco} e caratterizzata dagli attributi: \textit{Nome}, \textit{Cognome} e \textit{Ruolo}. Ogni membro dell'equipaggio è responsabile della manutenzione e riparazione dei sensori, partecipando all'associazione \textbf{OPERAZIONE} con i \textbf{SENSORI} secondo cardinalità $(0,N)$ da parte dell'equi-\\paggio e $(1,N)$ da parte dei sensori. Il tipo di operazione è specificato tramite l'attributo \textit{Operazione} della relazione \textbf{OPERAZIONE}. L'attributo \textit{Data} fa sì che un \textbf{MEMBRO DELL'EQUIPAGGIO} possa effettuare più operazioni dello stesso tipo sullo stesso sensore nel tempo. Un \textbf{MEMBRO DELL'EQUIPAGGIO} può inoltre essere coinvolto tramite la relazione \textbf{COINVOLGIMENTO} in $(0,N)$  \textbf{INTERVENTO}. Ogni \textbf{INTERVENTO} può coinvolgere $(1,N)$ membri.
    
    \item \textbf{INTERVENTO}: Ogni \textbf{INTERVENTO} è avviato per risolvere una specifica \textbf{ANOMALIA}. Gli attributi chiave di \textbf{INTERVENTO} includono un \textit{ID}, una \textit{Descrizione}, l'\textit{Esito dell'intervento} e la \textit{Data dell'intervento}. La relazione tra \textbf{ANOMALIA} e \textbf{INTERVENTO}, denominata \textbf{RISOLUZIO-\\NE}, ha cardinalità $(1,1)$ su entrambi i lati, garantendo che ogni \textbf{INTERVENTO} risolva un'unica \textbf{ANOMALIA} e che ogni \textbf{ANOMALIA} sia risolta da un unico \textbf{INTERVENTO}.
    
    \item \textbf{REPORT}: Ad ogni \textbf{MISSIONE} possono essere associati $(0,N)$ \textbf{REPORT} tramite la relazione \textbf{ANDAMENTO}. Un \textbf{REPORT} è relativo a un'unica \textbf{MISSIONE} ed ha dunque cardinalità $(1,1)$. Gli attributi di \textbf{REPORT} includono un \textit{ID} ed uno \textit{Stato}.
    
    \item \textbf{RILEVAZIONE}: Ogni \textbf{RILEVAZIONE} è associata esattamente a un $(1,1)$ \textbf{SENSORE} tramite la relazione denominata \textbf{MISURAZIONE}. Un \textbf{SENSORE}, tuttavia, può effettuare più rilevazioni, con una cardinalità pari a $(0,N)$. L'entità \textbf{RILEVAZIONE} include una chiave esterna che la collega all'entità \textbf{SENSORE} tramite la relazione \textbf{MISURAZIONE}, basandosi sugli attributi \textit{Data} e \textit{Ora}. Questi attributi, combinati con l'\textit{ID} del sensore, garantiscono l’identificazione univoca di ciascuna \textbf{RILEVAZIONE} effettuata da un determinato \textbf{SENSORE}. Si assume che un \textbf{SENSORE} non possa eseguire più rilevazioni nello stesso istante temporale definito dalla coppia (\textit{Data}, \textit{Ora}).
    
    \item \textbf{ANOMALIA}: Ogni \textbf{ANOMALIA} è associata esattamente a un $(1,1)$ \textbf{SENSORE} tramite la relazione denominata \textbf{STATO}. Un \textbf{SENSORE}, tuttavia, può presentare più anomalie, con una cardinalità pari a $(0,N)$. L'entità \textbf{ANOMALIA} include una chiave esterna che la collega all'entità \textbf{SENSORE} tramite la relazione \textbf{STATO}, basandosi sugli attributi \textit{Data} e \textit{Ora}. Questi attributi, combinati con l'\textit{ID} del sensore, garantiscono l'identifica-zione univoca di ciascuna \textbf{ANOMALIA} verificatasi in un determinato \textbf{SENSORE}. Si assume che in un \textbf{SENSORE} non possano verificarsi più anomalie nello stesso istante temporale definito dalla coppia (\textit{Data}, \textit{Ora}).
\end{itemize}


\subsection{Progettazione Logica}

La progettazione logica si articola in due fasi:

\begin{enumerate}
    \item \textbf{Trasformazione}: in questa fase, vengono rimossi tutti i costrutti del modello Entità/Relazione (E/R) che non sono direttamente traducibili nel modello logico, come gli attributi composti e gli attributi multi-valore. Gli attributi multi-valore vengono associati direttamente all’entità di partenza, mentre gli attributi composti vengono scomposti nei loro componenti e, se necessario, trasferiti a una nuova entità collegata all’entità originale.
    \item \textbf{Traduzione}: lo schema risultante dalla trasformazione viene convertito nel modello logico attraverso un insieme di regole predeterminate, che possono essere implementate anche tramite strumenti automatizzati. Questa fase non considera direttamente la semantica dei dati, ma si concentra sulla loro struttura.
\end{enumerate}

\subsubsection{Trasformazione}

Durante la fase di trasformazione, vengono eliminati tutti gli attributi che non sono direttamente traducibili nel modello logico. Di seguito vengono descritti i casi specifici presenti nello schema:

\begin{itemize}
    \item \textbf{Attributi multi-valore}: non sono presenti in questo caso, quindi non si rende necessaria alcuna operazione di trasformazione relativa a questa tipologia di attributi.
    \item \textbf{Attributi composti}: l'unico attributo composto identificato è \textbf{Coordinate}, associato all'entità \textit{SENSORE}. Per conformarsi ai requisiti del modello logico, questo attributo è stato scomposto nei suoi componenti: \textbf{Latitudine}, \textbf{Longitudine} e \textbf{Altitudine}. Tali componenti sono stati direttamente associati all’entità di partenza senza creare una nuova entità.
\end{itemize}

Di seguito è riportato lo schema trasformato per l'entità \textit{SENSORE}:\\

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{Media/Trasformazione_Sensore.png}
    \caption{Entità \textit{SENSORE} trasformata}
    \label{fig:schema_portante}
\end{figure}

\subsubsection{Traduzione}

La fase di traduzione consiste nella conversione dello schema Entità/Relazione (E/R), risultato della trasformazione, in uno schema relazionale conforme al modello logico relazionale. Questa operazione garantisce la corretta implementazione delle entità, delle relazioni e degli attributi all'interno del database relazionale.

\paragraph{Traduzione Entità}

Ogni entità del modello E/R diventa una relazione/tabella.
\begin{itemize}
    \item \textbf{Nome della tabella}: corrisponde al nome dell’entità al plurale.
    \item \textbf{Campi della tabella}: corrispondono agli attributi dell’entità.
\end{itemize}
\noindent
Risultato della Traduzione delle Entità:
\begin{lstlisting}
MISSIONI(ID, Obiettivo, Data_Inizio, Data_Fine, Stato);
MEMBI(ID, Nome, Cognome, Ruolo);
REPORT(ID, Stato);
INTERVENTI(ID, Descrizione);
ANOMALIE(ID, Data, Ora, Livello, Causa);
RILEVAZIONI(ID, Data, Ora, Valore);
ROBOT(ID, Tipo);
SENSORI(ID, Data_Installazione, Data_Ultimo_Controllo, Tipo, Stato_Operativo, Latitudine, Longitudine, Altitudine)
\end{lstlisting}

\paragraph{Traduzione Relazioni}
La traduzione delle relazioni tra le entità può essere effettuata attraverso diverse modalità, a seconda delle specifiche esigenze del sistema e delle caratteristiche del modello utilizzato. Di seguito si illustrano le modalità adottate per la progettazione del sistema in esame, con l'obiettivo di garantire una rappresentazione accurata e coerente delle interazioni tra le entità.
\begin{enumerate}
    \item Relazioni \textbf{N a N}
    \begin{itemize}
        \item Ogni associazione N a N diventa una tabella con:
        \begin{itemize}
            \item \textbf{Nome}: corrisponde al nome dell’associazione, al plurale.
            \item \textbf{Campi}: includono gli identificatori delle due entità che collega, più eventuali attributi dell’associazione.
            \item \textbf{Chiave primaria}: composta dalla coppia dei due identificatori.
            \item \textbf{Vincoli di integrità referenziale}: garantiscono la consistenza con le entità collegate.
        \end{itemize}
    \end{itemize}
    \begin{lstlisting}
    UTILIZZO_SENSORI (Sensore: Sensori, Missione: Missioni);
    UTILIZZO_ROBOT (Robot: Robot, Missione: Missioni);
    PARTECIPAZIONI (Missione: Missioni, Membro_Equipaggio: Membri_Equipaggio);
    OPERAZIONI (Membro_Equipaggio: Membri_Equipaggio, Sensore: Sensori, Operazione, Data);
    COINVOLGIMENTI (Membro_Equipaggio: Membri_Equipaggio, Intervento: Interventi)
    \end{lstlisting}

    \item Relazioni \textbf{1 a N}
    \begin{itemize}
        \item Gli \textbf{attributi dell’entità lato 1} e gli \textbf{attributi della relazione} vengono aggiunti come campi all’entità lato N.
        \item \textbf{Chiave primaria}: rimane quella dell’entità lato N.
        \item Questa scelta consente di ridurre il numero di tabelle, evitando join complessi a 3 tabelle.
    \end{itemize}
    \begin{lstlisting}
    REPORT (ID, Stato, Data, Missione: Missioni);
    RILEVAZIONI (ID, Data, Ora, Valore, Sensore: Sensori);
    ANOMALIE (ID, Data, Ora, Livello, Causa, Sensore: Sensori);
    \end{lstlisting}

    \item Relazioni \textbf{1 a 1}
    \begin{itemize}
        \item Ogni associazione 1 a 1 diventa una tabella con:
        \begin{itemize}
            \item \textbf{Campi}: includono gli identificatori delle entità che collega, più eventuali attributi.
            \item \textbf{Chiave primaria}: si sceglie l’identificatore dell’entità con cardinalità minima e partecipazione obbligatoria, per evitare valori NULL.
        \end{itemize}
    \end{itemize}
    \begin{lstlisting}
    RISOLUZIONI (Intervento: Interventi, Anomalia: Anomalie, Esito_Intervento, Data_Intervento)
    \end{lstlisting}
\end{enumerate}

\subsubsection{Modello E/R avanzato}

Le gerarchie di generalizzazione/specializzazione non possono essere direttamente rappresentate nel modello logico relazionale, poiché quest'ultimo non prevede un costrutto equivalente. Per superare questa limitazione, il modello E/R è stato esteso con l'introduzione del costrutto di \textbf{generalizzazione/specializzazione}. \\

\noindent
Il costrutto di generalizzazione può essere trasformato in schemi traducibili nel modello logico seguendo tre modalità principali.\\

\noindent
Per questo progetto è stata adottata la modalità di \textbf{accorpamento della superclasse nelle sottoclassi}:
\begin{itemize}
    \item \textbf{Eliminazione dell’entità padre}: l'entità padre (superclasse) viene eliminata dallo schema.
    \item \textbf{Eredità degli attributi e delle relazioni}: grazie alla proprietà dell’eredità, gli attributi, l’identificatore e le relazioni a cui partecipava l’entità padre vengono trasferiti integralmente alle entità figlie (sottoclassi).
\end{itemize}

\noindent
In particolare la specializzazione è di tipo totale-disgiunta:
\begin{itemize}
    \item \textbf{Totale}: Ogni istanza della superclasse deve appartenere ad almeno una sottoclasse. Ogni risorsa deve essere necessariamente o un "sensore" o "robot".
    \item \textbf{Disgiunta}: Un'istanza della superclasse può appartenere a una sola sottoclasse alla volta. Una risorsa può essere un "sensore" o "robot", ma non entrambi contemporaneamente.
\end{itemize}

\noindent
In figura (Figura \ref{fig:specializzazione}) è riportato il risultato dell'accorpamento relativo alla superclasse \textit{RISORSA} e alle sottoclassi \textit{ROBOT} e \textit{SENSORE}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{Media/Generalizzazione_Specializzazione.png}
    \caption{accorpamento di \textit{RISORSA} in \textit{ROBOT} e \textit{SENSORE}}
    \label{fig:specializzazione}
\end{figure}

\subsection{Progettazione Fisica}

I tipi di dato utilizzati per la realizzazione di questo progetto sono:

\begin{itemize}
    \item \textbf{DATE}: Utilizzato per tutte le date presenti;
    \item \textbf{INTEGER}: per tutti gli ID, formati esclusivamente da numeri e non da lettere;
    \item \textbf{VARCHAR2(N)}: per tutti gli attributi di tipo testuali, ad esempio nome, cognome, descrizione, ecc.;
    \item \textbf{FLOAT}: Utilizzato per rappresentare valori numerici con la necessità di precisione decimale, ad esempio coordinate geografiche (latitudine, longitudine, altitudine) o valori rilevati dai sensori;
    \item \textbf{TIMESTAMP}: Utilizzato per rappresentare data e ora in modo dettagliato, includendo secondi e frazioni di secondo, ad esempio per registrare eventi come rilevazioni o anomalie con un'accurata marcatura temporale.
\end{itemize}

\subsubsection{Occupazione tabelle}
Viene ora presentata una stima dell'occupazione in byte per le tabelle di un database progettato per un DBMS Oracle. Ogni tabella è analizzata in base ai tipi di dati delle sue colonne.

\paragraph{Tipi di Dati e Dimensioni}
\begin{itemize}
    \item \texttt{INT}: 4 byte
    \item \texttt{VARCHAR2(n)}: fino a $n$ byte
    \item \texttt{DATE}: 7 byte
    \item \texttt{TIMESTAMP}: 11 byte
    \item \texttt{FLOAT}: 8 byte
\end{itemize}

\noindent
Le dimensioni calcolate sono espresse in byte per riga e in MB per il numero stimato di righe.

\begin{itemize}
    \item \textbf{MISSIONI}: $4 + 255 + 7 + 7 + 50 = 323$ byte, 1.000 righe \(\approx 0,31\,\text{MB}\)
    \item \textbf{MEMBRI}: $4 + 100 + 100 + 100 = 304$ byte, 500 righe \(\approx 0,14\,\text{MB}\)
    \item \textbf{SENSORI}: $4 + 7 + 7 + 100 + 50 + 8 + 8 + 8 = 192$ byte, 300 righe \(\approx 0,05\,\text{MB}\)
    \item \textbf{ROBOT}: $4 + 100 = 104$ byte, 100 righe \(\approx 0,01\,\text{MB}\)
    \item \textbf{ANOMALIE}: $4 + 7 + 11 + 50 + 255 + 4 = 331$ byte, 2.000 righe \(\approx 0,63\,\text{MB}\)
    \item \textbf{INTERVENTI}: $4 + 255 = 259$ byte, 1.000 righe \(\approx 0,25\,\text{MB}\)
    \item \textbf{RISOLUZIONI}: $4 + 4 + 255 + 7 = 270$ byte, 1.000 righe \(\approx 0,26\,\text{MB}\)
    \item \textbf{RILEVAZIONI}: $4 + 7 + 11 + 8 + 4 = 34$ byte, 10.000 righe \(\approx 0,32\,\text{MB}\)
    \item \textbf{REPORT}: $4 + 50 + 7 + 4 = 65$ byte, 500 righe \(\approx 0,03\,\text{MB}\)
    \item \textbf{UTILIZZO\_ROBOT}: $4 + 4 = 8$ byte, 1.000 righe \(\approx 0,01\,\text{MB}\)
    \item \textbf{UTILIZZO\_SENSORI}: $4 + 4 = 8$ byte, 1.000 righe \(\approx 0,01\,\text{MB}\)
    \item \textbf{COINVOLGIMENTI}: $4 + 4 = 8$ byte, 500 righe \(\approx 0,004\,\text{MB}\)
    \item \textbf{OPERAZIONI}: $4 + 4 + 255 + 7 = 270$ byte, 2.000 righe \(\approx 0,51\,\text{MB}\)
    \item \textbf{PARTECIPAZIONI}: $4 + 4 = 8$ byte, 1.000 righe \(\approx 0,01\,\text{MB}\)
\end{itemize}

\noindent
Le dimensioni teoriche sono calcolate considerando i tipi di dati e ignorando eventuali overhead di gestione. Per una stima complessiva, è necessario moltiplicare queste dimensioni per il numero di righe previste in ciascuna tabella, includendo un margine del 10-20\% per l'indicizzazione e altri metadati.


\subsubsection{Tabelle}
Di seguito viene presentato il codice SQL necessario per la creazione delle tabelle del database, come descritto nelle fasi precedenti.
\begin{lstlisting}
-- Tabella MISSIONI
CREATE TABLE MISSIONI (
    ID INT,
    Obiettivo VARCHAR2(255) NOT NULL,
    Data_Inizio DATE NOT NULL, --NOT NULL o no ?
    Data_Fine DATE,
    Stato VARCHAR2(50) NOT NULL
);

-- Tabella MEMBRI
CREATE TABLE MEMBRI (
    ID INT,
    Nome VARCHAR2(100) NOT NULL,
    Cognome VARCHAR2(100) NOT NULL,
    Ruolo VARCHAR2(100) NOT NULL
);

-- Tabella SENSORI
CREATE TABLE SENSORI (
    ID INT,
    Data_Installazione DATE NOT NULL,
    Data_Ultimo_Controllo DATE,
    Tipo VARCHAR2(100) NOT NULL,
    Latitudine FLOAT NOT NULL,
    Longitudine FLOAT NOT NULL,
    Altitudine FLOAT NOT NULL
);

-- Tabella ROBOT
CREATE TABLE ROBOT (
    ID INT,
    Tipo VARCHAR2(100) NOT NULL
);

-- Tabella ANOMALIE
CREATE TABLE ANOMALIE (
    ID INT,
    Data DATE NOT NULL,
    Ora TIMESTAMP NOT NULL,
    Livello VARCHAR2(50) NOT NULL,
    Causa VARCHAR2(255) NOT NULL,
    Sensori INT
);

-- Tabella INTERVENTI
CREATE TABLE INTERVENTI (
    ID INT,
    Descrizione VARCHAR2(255) NOT NULL
);

-- Tabella RISOLUZIONI
CREATE TABLE RISOLUZIONI (
    Anomalie INT,
    Interventi INT,
    Esito_Intervento VARCHAR2(255),
    Data_Intervento DATE
);

-- Tabella RILEVAZIONI
CREATE TABLE RILEVAZIONI (
    ID INT,
    Data DATE NOT NULL,
    Ora TIMESTAMP NOT NULL,
    Valore FLOAT NOT NULL,
    Sensori INT
);

-- Tabella REPORT
CREATE TABLE REPORT (
    ID INT,
    Stato VARCHAR2(50) NOT NULL,
    Missioni INT
);

-- Tabella UTILIZZO_ROBOT
CREATE TABLE UTILIZZO_ROBOT (
    Robot INT,
    Missioni INT
);

-- Tabella UTILIZZO_SENSORI
CREATE TABLE UTILIZZO_SENSORI (
    Sensori INT,
    Missioni INT
);

-- Tabella COINVOLGIMENTI
CREATE TABLE COINVOLGIMENTI (
    Membri INT,
    Interventi INT
);

-- Tabella OPERAZIONI
CREATE TABLE OPERAZIONI (
    Membri INT,
    Sensori INT,
    Stato_Operativo VARCHAR2(50) NOT NULL,
    Operazione VARCHAR2(255)
);

-- Tabella PARTECIPAZIONI
CREATE TABLE PARTECIPAZIONI (
    Missione INT,
    Membri INT
);

-- Tabella SENSORI_MISSIONI
CREATE TABLE SENSORI_MISSIONI (
    Sensore_ID INT,
    Missione_ID INT,
    PRIMARY KEY (Sensore_ID, Missione_ID),
    FOREIGN KEY (Sensore_ID) REFERENCES SENSORI(ID),
    FOREIGN KEY (Missione_ID) REFERENCES MISSIONI(ID)
);

-- Tabella MEMBRI_MISSIONI
CREATE TABLE MEMBRI_MISSIONI (
    Membro_ID INT,
    Missione_ID INT,
    PRIMARY KEY (Membro_ID, Missione_ID),
    FOREIGN KEY (Membro_ID) REFERENCES MEMBRI(ID),
    FOREIGN KEY (Missione_ID) REFERENCES MISSIONI(ID)
);
\end{lstlisting}

\subsubsection{Chiavi primarie}

Di seguito viene riportato il codice SQL necessario  per la creazione dei vincoli di chiave primaria utilizzando la notazione "\texttt{PK\_NomeTabella}" per una maggiore chiarezza e standardizzazione e per aiutare l'individuazione di eventuali errori.

\begin{lstlisting}
ALTER TABLE MISSIONI ADD CONSTRAINT PK_MISSIONI PRIMARY KEY (ID);
ALTER TABLE MEMBRI ADD CONSTRAINT PK_MEMBRI PRIMARY KEY (ID);
ALTER TABLE SENSORI ADD CONSTRAINT PK_SENSORI PRIMARY KEY (ID);
ALTER TABLE ROBOT ADD CONSTRAINT PK_ROBOT PRIMARY KEY (ID);
ALTER TABLE ANOMALIE ADD CONSTRAINT PK_ANOMALIE PRIMARY KEY (ID);
ALTER TABLE INTERVENTI ADD CONSTRAINT PK_INTERVENTI PRIMARY KEY (ID);
ALTER TABLE RILEVAZIONI ADD CONSTRAINT PK_RILEVAZIONI PRIMARY KEY (ID);
ALTER TABLE REPORT ADD CONSTRAINT PK_REPORT PRIMARY KEY (ID);
ALTER TABLE RISOLUZIONI ADD CONSTRAINT PK_RISOLUZIONI PRIMARY KEY (Anomalie, Interventi);
ALTER TABLE UTILIZZO_ROBOT ADD CONSTRAINT PK_UTILIZZO_ROBOT PRIMARY KEY (Robot, Missioni);
ALTER TABLE UTILIZZO_SENSORI ADD CONSTRAINT PK_UTILIZZO_SENSORI PRIMARY KEY (Sensori, Missioni);
ALTER TABLE COINVOLGIMENTI ADD CONSTRAINT PK_COINVOLGIMENTI PRIMARY KEY (Membri, Interventi);
ALTER TABLE OPERAZIONI ADD CONSTRAINT PK_OPERAZIONI PRIMARY KEY (Membri, Sensori);
ALTER TABLE PARTECIPAZIONI ADD CONSTRAINT PK_PARTECIPAZIONI PRIMARY KEY (Missione, Membri);
\end{lstlisting}

\subsubsection{Chiavi esterne}
Di seguito viene riportato il codice SQL necessario  per la creazione dei vincoli di chiave esterna utilizzando la notazione "\texttt{FK\_TabellaReferenziante\_TabellaRefe-\\renziata}".
\begin{lstlisting}
ALTER TABLE ANOMALIE ADD CONSTRAINT FK_ANOMALIE_SENSORI FOREIGN KEY (Sensori) REFERENCES SENSORI(ID);
ALTER TABLE RISOLUZIONI ADD CONSTRAINT FK_RISOLUZIONI_ANOMALIE FOREIGN KEY (Anomalie) REFERENCES ANOMALIE(ID);
ALTER TABLE RISOLUZIONI ADD CONSTRAINT FK_RISOLUZIONI_INTERVENTI FOREIGN KEY (Interventi) REFERENCES INTERVENTI(ID);
ALTER TABLE RILEVAZIONI ADD CONSTRAINT FK_RILEVAZIONI_SENSORI FOREIGN KEY (Sensori) REFERENCES SENSORI(ID);
ALTER TABLE REPORT ADD CONSTRAINT FK_REPORT_MISSIONI FOREIGN KEY (Missioni) REFERENCES MISSIONI(ID);
ALTER TABLE UTILIZZO_ROBOT ADD CONSTRAINT FK_UTILIZZO_ROBOT_ROBOT FOREIGN KEY (Robot) REFERENCES ROBOT(ID);
ALTER TABLE UTILIZZO_ROBOT ADD CONSTRAINT FK_UTILIZZO_ROBOT_MISSIONI FOREIGN KEY (Missioni) REFERENCES MISSIONI(ID);
ALTER TABLE UTILIZZO_SENSORI ADD CONSTRAINT FK_UTILIZZO_SENSORI_SENSORI FOREIGN KEY (Sensori) REFERENCES SENSORI(ID);
ALTER TABLE UTILIZZO_SENSORI ADD CONSTRAINT FK_UTILIZZO_SENSORI_MISSIONI FOREIGN KEY (Missioni) REFERENCES MISSIONI(ID);
ALTER TABLE COINVOLGIMENTI ADD CONSTRAINT FK_COINVOLGIMENTI_MEMBRI FOREIGN KEY (Membri) REFERENCES MEMBRI(ID);
ALTER TABLE COINVOLGIMENTI ADD CONSTRAINT FK_COINVOLGIMENTI_INTERVENTI FOREIGN KEY (Interventi) REFERENCES INTERVENTI(ID);
ALTER TABLE OPERAZIONI ADD CONSTRAINT FK_OPERAZIONI_MEMBRI FOREIGN KEY (Membri) REFERENCES MEMBRI(ID);
ALTER TABLE OPERAZIONI ADD CONSTRAINT FK_OPERAZIONI_SENSORI FOREIGN KEY (Sensori) REFERENCES SENSORI(ID);
ALTER TABLE PARTECIPAZIONI ADD CONSTRAINT FK_PARTECIPAZIONI_MISSIONE FOREIGN KEY (Missione) REFERENCES MISSIONI(ID);
ALTER TABLE PARTECIPAZIONI ADD CONSTRAINT FK_PARTECIPAZIONI_MEMBRI FOREIGN KEY (Membri) REFERENCES MEMBRI(ID);
\end{lstlisting}

\subsubsection{Vincoli di check}
In fine, si riportano i comandi SQL per la creazione di vincoli di check utilizzando la notazione "\texttt{CK\_Tabella\_Campo}". Questo approccio consente di garantire che i valori di determinati campi rispettino i criteri specificati, fornendo così un ulteriore livello di controllo sull'integrità dei dati.

\begin{lstlisting}
    ALTER TABLE SENSORI ADD CONSTRAINT CK_SENSORI_TIPO CHECK (Tipo IN ('Temperatura', 'Pressione', 'Gas', 'Radiazioni', 'Geologia'));
    
    ALTER TABLE OPERAZIONI ADD CONSTRAINT CK_OPERAZIONI_STATO CHECK (Stato_Operativo IN ('Attivo', 'Standby', 'Manutenzione', 'Malfunzionante'));
    
    ALTER TABLE ANOMALIE ADD CONSTRAINT CK_ANOMALIE_LIVELLO CHECK (Livello IN ('Bassa', 'Media', 'Alta', 'Critica'));
    
    ALTER TABLE MISSIONI ADD CONSTRAINT CK_MISSIONI_STATO CHECK (Stato IN ('Pianificata', 'In corso', 'Completata', 'Annullata'));
\end{lstlisting}



\renewcommand{\thefootnote}{}
\noindent
\footnote{\textbf{N.B.}: I quattro snippet di codice SQL mostrati verranno implementati nel DBMS tramite appositi script contenenti il codice: (1) \texttt{create\_table.sql}, (2) \texttt{constraint.sql}.}
\renewcommand{\thefootnote}{\arabic{footnote}}


